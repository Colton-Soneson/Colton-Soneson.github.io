<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
		const canvas = document.querySelector("canvas");

		if (!navigator.gpu) 
		{
			throw new Error("WebGPU not supported on this browser.");
		}
		
		//adapter options can be passed in for specific hardware feature requests
		const adapter = await navigator.gpu.requestAdapter();
		if (!adapter) 
		{
			throw new Error("No appropriate GPUAdapter found.");
		}
		
		//device options can be passed in for specific hardware feature requests
		const device = await adapter.requestDevice();
		
		
		const context = canvas.getContext("webgpu");
		const canvasFormat = navigator.gpu.getPreferredCanvasFormat();	//webgpu's suggestion for canvas type
		context.configure({
			device: device,
			format: canvasFormat,	//format is the texture format that should be used
		});
		
		//interface to record GPU Commands, necessary for basically everything
		const encoder = device.createCommandEncoder();
		
		//begin render pass
		//	give texture view property of colorAttachment
		const pass = encoder.beginRenderPass({
			colorAttachments: [{
				view: context.getCurrentTexture().createView(),	//getCurrentTexture is getting ENTIRE canvas in this case
				loadOp: "clear",		//clear texture when renderpass starts
				storeOp: "store",		//once rp is finished, store results into the texture
			}]	
		});
		
		//end to the render pass "pass"
		pass.end();
		
		//command buffer for recording commands, assigned by finish function on command encoder
		//const commandBuffer = encoder.finish();
		
		//submit commands in queue, submit function can take an array of command buffers if needed
		//device.queue.submit([commandBuffer]);
		
		//combining the two into one, and its done
		device.queue.submit([encoder.finish()]);
		
		//--------------CANVAS COLOR-----------------
		//new render pass, so different from the first
		const encoder2 = device.createCommandEncoder();
		const pass2 = encoder2.beginRenderPass({
		colorAttachments: [{
			view: context.getCurrentTexture().createView(),
			loadOp: "clear",
			clearValue: { r: 0, g: 0, b: 0.4, a: 1 }, // New line
			storeOp: "store",
			}],
		});
		
		pass2.end();
		
		device.queue.submit([encoder2.finish()]);
		//--------------------------------------------
		
		const vertices = new Float32Array([
		//   X,    Y,
			-0.8, -0.8, // Triangle 1 (Blue)
			0.8, -0.8,
			0.8,  0.8,
			
			-0.8, -0.8, // Triangle 2 (Red)
			0.8,  0.8,
			-0.8,  0.8,
		]);
		
		//function should return GPUShaderModule object if compiled with valid results, code itself is WGSL
		const cellShaderModule = device.createShaderModule({
		label: "Cell shader",
		code: `
			@vertex
			fn vertexMain() -> @builtin(position) vec4f {	// -> is for what the function returns, value returned is assigned with @builtin 
				return vec4f(0, 0, 0, 1); // (X, Y, Z, W) W is always 1 for 4x4 mat math
			}
		`
		});
		
		
		
		//GPU Side memory management done through GPUBuffer objects
		//	since its so simple, theres no need to do index buffer, but the process I imagine is similar
		const vertexBuffer = device.createBuffer({
			label: "Cell vertices",		//just helps to identify object, can be anything you type
			size: vertices.byteLength,	//for 12 float vertices thats 48 bytes, cant be resized after creation
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,	//its use is for vertex data, and that you want to copy data into it
		});
		
		//copy vertex data to buffer
		device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
		
		//now tell WebGPU what the hell to do with the info
		const vertexBufferLayout = {
		arrayStride: 8,			//number of bytes gpu needs to skip forward to get to the next vertex (with two vertices per vertex, thats 
								//	two 32 bit floats, so 2 x 4(bytes) = 8 bytes
		attributes: [{			//stuff like color, normal direction, etc
			format: "float32x2",//cant be anything, there is a list of GPUVertexFormat types in this case, its specific to pass in
			offset: 0,			//how many bytes into the vertex this attribute starts, use if you have more than one attribute
			shaderLocation: 0, // Position, see vertex shader, can be 0 - 15 and is unique to each attribute
			}],
		};
		
		
		
    </script>
  </body>
</html>